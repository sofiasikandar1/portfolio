; ======================================================================
;
; washington oregon groundfishery model
;
; overview
; this model is a spatially explicit  abstract simulation of the 
; US West coast groundfishery for Dover Sole (Microstomus pacificus)
; and Darkblotch Rockfish (Sebastes crameri).  the model simulates
; commercial fishing activities and fisheries management policies
; for the Washington and Oregon commercial fisheries.
;
;
; geospatial configuration
; the model uses a simplified but spatially explicit landscape 
; consisting of a region 200x900 KM^2  situated off the WA and OR
; Pacific coastlines.  The region is divided into 100 grids each
; 20x90 KM  in which estimated stock abundance for the two species
; as well as CPUE estimates are maintained.  
;
;
; biological model
; stock growth is modeled using a logistic growth equation  with
; each grid modeled as a separate population.  A small amount of
; stock migration is allowed to account for biological movement.
; initial stock sizes are based on NOAA stock size assessments
; (see www.pcouncil.org for copies).
;
;
; fisher model
; the fleet is modeled as a set of N ~= 120 mid-sized commercial
; fishing vessels all based out of the port of Astoria OR.
;
;
; policy models
; the model implements several widely used fisheries management policies.
;
; Total Allowable Catch (TAC) : this model is the "baseline" case
;     the fishery is assigned a TAC and fishers are free to fish
;     as much and as fast as possible until the TAC is exceeded
;
; Marine Protected Areas (MPA) : this model simulates the presence
;     of MPAs in which fishing for target and/or bycatch species
;     is restricted.
;
; Temporal Closures : this model simulates specific times at which
;     fishing for target species is authorized
;
; Landing Taxes : this model simulates the imposition of landing
;     taxes for specific species.  Currently not allowed under US
;     fisheries management law (Magnuson).
;
; Individual Transfer Quotas (ITQ) : this model simulates the 
;     use of ITQs  where each fisher is assigned a specific portion
;     of the TAC.  Fishers may elect to fish  or may lease their
;     quota to other fishers instead.
;
; ======================================================================
;
; this model is developed in partial fulfillment for the requirements
; of the Doctor of Philosophy degree in Computational Social Science
; at George Mason University.
; ======================================================================
; version history:
; v11 : baseline model
;
; v11a: fixes to fisher site selection algorithm
; ======================================================================

;
; declare simulation global vars
;
globals [
  day                      ; current day of the month (1-31)
  month                    ; current month of the year (1-12)
  year                     ; current year (2000 - 2050)
  season                   ; current season (winter  spring  summer  fall)
  previous-season          ; previous season  used to trigger spawning at spring-summer transition
  spawning-time?           ; flag set when spawning time is active  at spring-summer transition
  new-month?               ; flag set to indicate a new month  used for fish movement
  time-of-day              ; current time of day (day  night)
  julian-day               ; current julian day (1 - 365)
  fleet-size               ; number of boats in the fleet    
  harbor-spots             ; ocean locations near the port where boats can harbor
  
  START-YEAR               ; first year of simulation
  MAX-YEAR                 ; final year of simulation  also used to halt sim
  DAYS-PER-MONTH           ; list of days per month (skipping leap years for simplicity)
  DAYS-PER-YEAR            ; 365 days in a year
  
  dover-sole-r             ; reproductive rate for dover-sole
  darkblotched-rockfish-r  ; reproductive rate for darkblotched-rockfish
  
  MPA-TILE-LIST            ; list of tiles that are designated as MPAs
  SEASONAL-CLOSURE-LIST    ; list of months that are designated as fishery closures
  LANDING-TAX-RATE         ; amount of tax due if landing taxes imposed

  ;
  ; ITQ global vars
  ;
  Dover-TAC                      ; amount of TAC for Dover, in lbs (not MT)
  Rockfish-TAC                   ; amount of TAC for Rockfish, in lbs (not MT)
  
  Dover-TAC-share-per-boat       ; Dover TAC share (in %) per boat 
  Rockfish-TAC-share-per-boat    ; Rockfish TAC share (in %) per boat
  
  Dover-Quota-per-boat           ; Dover quota in lbs per boat
  Rockfish-Quota-per-boat        ; Rockfish quota in lbs per boat

  average-dover-quota-price      ; overall dover quota price averaged across all boats
  average-rockfish-quota-price   ; overall rockfish quota price averaged across all boats
  dover-landing-price-per-lb     ; landing price for Dover in $/lb
  rockfish-landing-price-per-lb  ; landing price for Rockfish in $/lb
  
  ;
  ; Data file with CPUE tile data
  ;
  CPUE-DATA-FILE-NAME             ; "ORWA CPUE All Bottom Trawl Excerpt from Matt 17 May 2015.txt" 
]


to setup-globals
  set day 1
  set month 1
  set year 2000
  set season "winter"
  set previous-season "fall"
  set new-month? false
  set time-of-day "day"
  set julian-day 1
  set fleet-size 120
  set harbor-spots nobody
  
  set START-YEAR 2000
  set MAX-YEAR 2050
  
  set dover-sole-r 0.04
  set darkblotched-rockfish-r 0.02
  
  ;
  ; MPA-TILE-LIST
  ;
  ; this is the list of TILES (not patches!) that are considered
  ; active MPAs if the MPAs-active? user interface switch is enabled
  ;
  set MPA-TILE-LIST (list 22 23 24 25 26 27 43 44 45 46 47 48 63 64 65 66 67 68)
 
  ;
  ; SEASONAL-CLOSURE-LIST
  ;
  ; this is the list of calendar months (starting with Jan = 1)
  ; that are closed for fishing if the Seasonal-closure? user interface
  ; switch is enabled
  ;
  set SEASONAL-CLOSURE-LIST (list 1 3 5 7 9 11 )

  ;
  ; LANDING-TAX-RATE
  ;
  ; this is the amount of catch that is taxed if the 
  ; Landing-Taxes? user interface switch is enabled
  ;
  set LANDING-TAX-RATE 0.05
    
  ;
  ; ITQ vars
  ;
  set Dover-TAC 300000
  set Rockfish-TAC 100000
  set Dover-TAC-share-per-boat ( 1 / fleet-size )
  set Rockfish-TAC-share-per-boat ( 1 / fleet-size )
  set Dover-quota-per-boat ( Dover-TAC-share-per-boat * Dover-TAC )
  set Rockfish-quota-per-boat ( Rockfish-TAC-share-per-boat * Rockfish-TAC )
  
  set dover-landing-price-per-lb 2.50
  set rockfish-landing-price-per-lb 1.50
  
  ;
  ; data file for tiles
  ;
  ; set CPUE-DATA-FILE-NAME "ORWA CPUE All Bottom Trawl Excerpt from Matt 17 May 2015.txt"
  set CPUE-DATA-FILE-NAME "Oregon model CPUE data file v11a.txt"
end

;
; identify patch attributes
;
patches-own [
  patch-id                 ; arbitrary patch numeric ID
  grid-row                 ; which tile row (grid) does this patch fall into?
  grid-col                 ; which tile col (grid) does this patch fall into?
  cover-type               ; what is the cover type for this patch (land, ocean, harbor)
  
  primary-pcolor           ; what color should this patch be drawn using?
  alternate-pcolor         ; if not the primary color, what is the alternate color for this patch?
]

;
; setup a breed for the boats
;
breed [boats boat]
boats-own [
  boat-id                  ; arbitrary numeric ID for boat
  
  trip-phase               ; what phase of trip are we on? (in-port, outward-bound, on-station, homeward-bound)
  
  current-trip             ; data for our current fishing trip (or next upcoming trip)
                           ; (trip-rank grid-id start-time end-time planned-effort dover-catch rockfish-catch)
  
  trip-history             ; list of lists of past trips, where each trip is summarized as a tuple:
                           ; ( (grid-id start-time end-time planned-effort dover-catch rockfish-catch) ... )
                           
  catch-history            ; list of list of catches from all trips, summarized by grid-id as a tuple:
                           ; ( (grid-id dover-catch rockfish-catch) ... )
  
  preferred-grids          ; ordered list of preferred fishing grids (tile-id's)
                           ; ( tile-id-1 tile-id-2 tile-id-3 ... )
                           
  dover-catch              ; amount of dover sole caught (used during fishing operations)
  rockfish-catch           ; amount of rockfish caught (used during fishing operations)
  
  wealth                   ; current wealth in $
  cost-factor              ; used to express relative cost efficiency of boats 
                           ; 0.5 = low cost, 1.0 = average cost, 1.5 = high-cost
                           
  effort                   ; measures effort for a trip, in tows
  
  ;
  ;   ITQ variables
  ;
  dover-TAC-share               ; percent of Dover TAC assigned to this boat
  rockfish-TAC-share            ; percent of Rockfish TAC assigned to this boat
  
  dover-quota                   ; quota of Dover in lbs assigned to this boat
  rockfish-quota                ; quota of Rockfish in lbs assigned to this boat
  
  dover-quota-price             ; price in $ this boat assigns to Dover quota
  rockfish-quota-price          ; price in $ this boat assigns to Rockfish quota
  
  amt-dover-quota-remaining     ; amount of Dover quota remaining this year
  amt-rockfish-quota-remaining  ; amount of Rockfish quota remaining this year
  
  amt-dover-quota-needed        ; amount of Dover quota needed (if any)
  amt-rockfish-quota-needed     ; amount of Rockfish quota needed (if any)
  
  predicted-results             ; list of lists, holding predicted fishing outcomes for various locations
                                ; ( (grid-id total-profit
                                ;            expected-dover-catch expected-dover-cost 
                                ;            expected-dover-effort expected-dover-profit
                                ;            expected-rockfish-catch expected-rockfish-cost 
                                ;            expected-rockfish-effort expected-rockfish-profit) ... )
                                ;
                            
  best-spot                     ; grid-id with best expected profit
  highest-profit                ; amt in $ of highest expected grid-id
  
  gDover                        ; quota price for Dover
  gRockfish                     ; quota price for Rockfish
]

;
; setup a breed used for drawing lat-lon grid lines
;
breed [markers marker]
markers-own [
  marker-id
]

;
; setup a breed for tiling the patches
;
breed [ tiles tile ]
tiles-own [
  tile-id                   ; numeric id for tile
  tile-row                  ; row number for tile (0 starts at bottom edge)
  tile-col                  ; col number for tile (0 starts at left edge)
  tile-cover-type           ; determines if tile is ocean or land
  tile-patch-set            ; set of patches associated with this tile
  tile-is-mpa?              ; flag set to true if this tile is designated as an MPA
  
  
                            ;
                            ; dover fishery data for tile
                            ;
  dover-sole-stock-size
  dover-sole-K
  dover-sole-q
  dover-sole-day-CPUE-mean
  dover-sole-day-CPUE-stdev
  dover-sole-night-CPUE-mean
  dover-sole-night-CPUE-stdev
  
  ;
  ; rockfish fishery data for this tile
  ;
  darkblotched-rockfish-stock-size
  darkblotched-rockfish-K
  darkblotched-rockfish-q  
  darkblotched-rockfish-day-CPUE-mean
  darkblotched-rockfish-day-CPUE-stdev
  darkblotched-rockfish-night-CPUE-mean
  darkblotched-rockfish-night-CPUE-stdev
  
]

; setup-ocean
;
; setup the ocean patches
to setup-ocean
  ;
  ; initialize to all ocean
  ;
  let k 0
  let patch-list sort patches
  foreach patch-list [
    ask ? [
      set pcolor blue
      set cover-type "ocean"
      set patch-id k
      set k (k + 1)
    ]
  ]
  
  ;
  ; prettify the water
  ;
  ask patches [
    let variation random 5
    set pcolor blue - 4 + variation
  ]
  
  repeat 1 [
    ask patches with [ cover-type = "ocean" ] [
      let ocean-neigbors neighbors with [cover-type = "ocean"]
      let ave-ocean-neighbor-color mean [pcolor] of ocean-neigbors
      set pcolor (pcolor + ave-ocean-neighbor-color) / 2.0
    ]
  ]
  
  repeat 35 [
    ask patches with [ cover-type = "ocean" ] [
      let swap-partner one-of patches with [ cover-type = "ocean" ]
      if ([pxcor] of swap-partner < pxcor) and 
      ([pcolor] of swap-partner > pcolor) [
        let partner-color [pcolor] of swap-partner
        let my-color pcolor
        ask swap-partner [set pcolor my-color]
        set my-color partner-color
        set pcolor my-color
      ]
    ]
  ]
end

; setup-MPA
;
; sets color for patches in MPA
;
to setup-MPA
  foreach MPA-TILE-LIST [
    let mpa-tile ?
    ask get-tile-patchset get-tile-id mpa-tile [
      set pcolor alternate-pcolor
    ]
  ]
end

; reset-MPA
;
; resets color for patches in MPA
;
to reset-MPA
  foreach MPA-TILE-LIST [
    let mpa-tile ?
    ask get-tile-patchset get-tile-id mpa-tile [
      set pcolor primary-pcolor
    ]
  ]
end  

; setup-landscape
;
; manages setting up simulation landscape
;
to setup-landscape
  ;
  ; setup the ocean
  ;
  setup-ocean
  
  ;
  ; assign grids
  ;
  setup-grid-row-col
  
  ;
  ; draw stylized coast on eastern edge of map
  ;
  setup-coastal-region
  
  ;
  ; draw grid boundary lines
  ;
  draw-grid-boxes
  
  ;
  ; keep track of patch colors
  ;
  ask patches [
    set primary-pcolor pcolor
    set alternate-pcolor gray
  ]
end


; draw-grid-boxes
;
; draws bounding box lines for grids 
;
to draw-grid-boxes
  ;
  ; create a "pen" agent
  ;
  create-markers 1 [
    set shape "circle"
    set size 0.5
    set marker-id 1
    set color black
    set pen-size 1
  ]
  
  let num-lats 10
  let num-lons 10
  let delta-x (world-width) / num-lons
  let delta-y (world-height) / num-lats
  
  ;
  ; draw lat lines
  ;
  let xpos min-pxcor
  let ypos max-pycor
  let i 0
  while [ i < num-lats ] [
    ask markers [
      setxy xpos ypos
      set heading 0
      forward 0.35
      set heading 270
      forward 0.5
      set heading 90
      pen-down
      while [ can-move? 0.01 ]
      [
        forward 0.01
      ]
      forward 0.01
      pen-up
    ]
    set xpos min-pxcor
    set ypos (ypos - delta-y)
    set i (i + 1)
  ]
  ;
  ; draw bottom lat line
  set xpos min-pxcor
  set ypos min-pycor
  ask markers [
    setxy xpos ypos
    set heading 180
    forward 0.35
    set heading 270
    forward 0.5
    set heading 90
    pen-down
    while [ can-move? 0.01 ]
      [
        forward 0.01
      ]
    forward 0.01
    pen-up
  ]    
  
  ;
  ; draw lon lines
  ;
  set xpos min-pxcor
  set ypos max-pycor
  set i 0
  while [ i < num-lons ] [
    ask markers [
      setxy xpos ypos
      set heading 0
      forward 0.35
      set heading 270
      forward 0.5
      set heading 180
      pen-down
      while [ can-move? 0.1 ]
      [
        forward 0.1
      ]
      forward 0.1
      pen-up
    ]
    set xpos (xpos + delta-x)
    set ypos max-pycor
    set i (i + 1)
  ]  
  
  ;
  ; remove the marker
  ;
  ask markers [ die ]
end

; assign-grid-row-col
;
; assigns each patch to a parent grid
; grids are numbered from left to right  bottom to top
;
; 9-0 9-1 9-2 ... 9-7 9-8 9-9
; 8-0 8-1 8-2 ... 8-7 8-8 8-9
;
; ...
;
; 1-0 1-1 1-2 ... 1-7 1-8 1-9
; 0-0 0-1 0-2 ... 0-7 0-8 0-9
;
to setup-grid-row-col
  let lon-vals sequence min-pxcor (max-pxcor + 1) 2
  let lat-vals sequence min-pycor (max-pycor + 1) 9
  
  ;print (list "debug: lat-vals = " lat-vals)
  ;print (list "debug: lon-vals = " lon-vals)
  
  ;
  ; assign the lon grids
  ;
  let k 0
  let num-lons 10
  while [ k < num-lons ] [
    let p item k lon-vals
    let q item (k + 1) lon-vals
    let tmp patches with [ (pxcor >= p) and (pxcor < q) ]
    ask tmp [
      set grid-col k
    ]
    set k (k + 1)
  ]
  
  ;
  ; assign the lat grids
  ;
  set k 0
  let num-lats 10
  while [ k < num-lats ] [
    let p item k lat-vals 
    let q item (k + 1) lat-vals 
    let tmp patches with [ (pycor >= p) and (pycor < q) ]
    ask tmp [
      set grid-row k
    ]
    set k (k + 1)
  ]  
end

; assign-coastal-region
;
; make the eastern border have some land areas
;
to setup-coastal-region
  
  ;
  ; make a list of grids that should be land
  ;
  let coastal-grids (list
    (list 9 6) (list 9 7) (list 9 8) (list 9 9)
    (list 8 8) (list 8 9)
    (list 7 9)
    (list 5 9)
    (list 4 9)
    (list 3 7) (list 3 8) (list 3 9)
    (list 2 8) (list 2 9)
    (list 1 9)
    (list 0 8) (list 0 9))
  
  ;
  ; assign land grids appropriately
  ;
  foreach coastal-grids [
    let row-val item 0 ?
    let col-val item 1 ?
    ask patches with [(grid-row = row-val) and (grid-col = col-val) ]
      [
        set cover-type "land"
        set pcolor green
      ]
  ]
  
  ;
  ; prettify the land grids
  ;
  ask patches with [ cover-type = "land"] [
    let variation random 5
    set pcolor green - 4 + variation
  ]
  
  repeat 3 [
    ask patches with [ cover-type = "land" ] [
      let land-neigbors neighbors with [cover-type = "land"]
      let ave-land-neighbor-color mean [pcolor] of land-neigbors
      set pcolor (pcolor + ave-land-neighbor-color) / 2.0
    ]
  ]  
end

; assign-harbor
;
; for now  we only have one harbor
; hard-code assignment of Port of Astoria
;
to setup-harbors
  let harbor-list []
  set harbor-list fput (list 8 22) harbor-list
  
  foreach harbor-list [
    let next-harbor ?
    let patch-x item 0 next-harbor
    let patch-y item 1 next-harbor
    let harbor patch patch-x patch-y
    ask harbor [
      set pcolor red
      set cover-type "harbor"
    ]
  ]
end

; setup-tiles
;
; setup the tiles.  A tile is an accounting unit corresponding
; to a spatial grid.  We do this because a grid actually contains
; multiple patches  and we need an abstraction to manage resources
; across a larger spatial scale than just a single patch
;
; two modes are suppored:
; setup-tiles-random generates random fishery data
;
; setup-tiles-file reads a data file and assigns values based on the file contents
;    the file is a flat-ascii file with each line having the following format (\ indicates continuation)
;    note NetLogo requires the use of white space as a token separator
;
; num-rows
; num-cols
; tile-id  tile-row  tile-col  is-land?  \
;     dover-stocksize  dover-K  dover-q \
;     dover-day-cpue-mean  dover-day-cpue-std  dover-night-cpue-mean  dover-night-cpue-std  \
;     rockfish-stocksize  rockfish-K  rockfish-q  \
;     rockfish-day-cpue-mean  rockfish-day-cpue-std  rockfish-night-cpue-mean  rockfish-night-cpue-std
;
; tile-id  tile-row  tile-col  is-land?  \
;     dover-stocksize  dover-K  dover-q \
;     dover-day-cpue-mean  dover-day-cpue-std  dover-night-cpue-mean  dover-night-cpue-std  \
;     rockfish-stocksize  rockfish-K  rockfish-q  \
;     rockfish-day-cpue-mean  rockfish-day-cpue-std  rockfish-night-cpue-mean  rockfish-night-cpue-std
;
; tile-id  tile-row  tile-col  is-land?  \
;     dover-stocksize  dover-K  dover-q \
;     dover-day-cpue-mean  dover-day-cpue-std  dover-night-cpue-mean  dover-night-cpue-std  \
;     rockfish-stocksize  rockfish-K  rockfish-q  \
;     rockfish-day-cpue-mean  rockfish-day-cpue-std  rockfish-night-cpue-mean  rockfish-night-cpue-std
;
to setup-tiles
  
  ;let tile-mode "random"
  let tile-mode "file"
  
  ;
  ;  random setup
  ;
  if (tile-mode = "random") [
    setup-tiles-random
  ]
  
  ;
  ; set up tiles from file
  ;
  if (tile-mode = "file") [
    ; setup-tiles-file "ORWA grid data v01.txt"
    ; setup-tiles-file "ORWA CPUE All Bottom Trawl Excerpt from Matt 17 May 2015.txt" 
    setup-tiles-file CPUE-DATA-FILE-NAME   
  ]
  
  ;
  ; now associate patches with each tile
  ;
  ask tiles [
    let tile-row-val [tile-row] of self
    let tile-col-val [tile-col] of self
    set tile-patch-set patches with [ (grid-row = tile-row-val) and (grid-col = tile-col-val) ]
  ]
  
end

; setup-tiles-random
;
; randomly populate tiles with fishery stock data
;
to setup-tiles-random
  
  let num-rows 10
  let num-cols 10
  let num-tiles (num-rows * num-cols)
  
  ;
  ; create the tiles
  ;
  create-tiles num-tiles [
    set hidden? true
    set tile-cover-type "ocean"
    set tile-is-mpa? false
  ]
  let tile-list sort tiles
  let k 0
  foreach tile-list [
    ask ? [ 
      set tile-id k
      set k (k + 1)
    ]
  ]
  
  ;
  ; assign attributes to the tiles
  ;
  let row-val 0
  let col-val 0
  set k 0
  while [ row-val < num-rows ] [
    set col-val 0
    while [col-val < num-cols] [
      
      ;
      ; set tile attributes
      ;
      ask tiles with [tile-id = k] [
        
        ;
        ; set row and col
        ;
        set tile-row row-val
        set tile-col col-val
        
        ;
        ; set fishery attributes (randomly)
        ;
        set dover-sole-stock-size random 100000
        set dover-sole-K 100000 + random 100000
        set dover-sole-q random-float 0.5
        set dover-sole-day-CPUE-mean random 100
        set dover-sole-day-CPUE-stdev random 20
        set dover-sole-night-CPUE-mean random 100
        set dover-sole-night-CPUE-stdev random 20
        
        set darkblotched-rockfish-stock-size random 10000
        set darkblotched-rockfish-K 10000 + random 20000
        set darkblotched-rockfish-q random-float 0.2
        set darkblotched-rockfish-day-CPUE-mean random 50
        set darkblotched-rockfish-day-CPUE-stdev random 10
        set darkblotched-rockfish-night-CPUE-mean random 50
        set darkblotched-rockfish-night-CPUE-stdev random 10
        
      ]
      
      set k (k + 1)
      set col-val (col-val + 1)
    ]
    set row-val (row-val + 1)
  ]
  
  ;
  ; now reset tiles that fall on land
  ;
  set row-val 0
  set col-val 0
  set k 0
  while [ row-val < num-rows ] [
    
    set col-val 0
    while [col-val < num-cols] [
      
      let is-land? false
      
      let patches-in-tile patches with [ (grid-row = row-val) and (grid-col = col-val) ]
      if (count patches-in-tile with [cover-type = "land"] > 0) [
        set is-land? true
      ]
      
      ;
      ; test for corresponding grid-id
      ; if grid-id is on land  set biological values to 0
      ;
      let current-tile one-of tiles with [(tile-row = row-val) and (tile-col = col-val)]
      if is-land? = true [
        ask current-tile [
          ;;print (list "debug: just reset tile at row-col " row-val "-" col-val " to LAND...")
          set tile-cover-type "land"
          
          set dover-sole-stock-size 0
          set dover-sole-K 1
          set dover-sole-q random-float 0.0
          set dover-sole-day-CPUE-mean 0
          set dover-sole-day-CPUE-stdev 0
          set dover-sole-night-CPUE-mean 0
          set dover-sole-night-CPUE-stdev 0
          
          set darkblotched-rockfish-stock-size 0
          set darkblotched-rockfish-K 1
          set darkblotched-rockfish-q 0
          set darkblotched-rockfish-day-CPUE-mean 0
          set darkblotched-rockfish-day-CPUE-stdev 0
          set darkblotched-rockfish-night-CPUE-mean 0
          set darkblotched-rockfish-night-CPUE-stdev 0
        ]
      ]
      set col-val (col-val + 1)
      set k (k + 1)
    ]
    set row-val (row-val + 1)
  ]
end

;
; setup-tiles-file [ data-file-name ]
;
; setup the tiles by importing data from the specified data-file-name 
;
; note: we assume all tiles are ocean tiles when the file is read.
; then  after loading the file  we apply a land mask to adjust for
; tiles that are known to be on land.  Stock is transferred to
; ocean tiles  and the land-tiles are reset to 0.
;
;
to setup-tiles-file [ data-file-name ]
  ;
  ; check to see if we can find the file
  ;
  if not (file-exists? data-file-name) [
    print (list "error: can't locate specified data file... " data-file-name)
  ]
  
  ;
  ; open and read the file
  ;
  file-open data-file-name
  file-close
  file-open data-file-name
  let num-rows file-read
  let num-cols file-read
  
  let num-tiles (num-rows * num-cols)
  
  ; print (list "debug: just read file " data-file-name "  numrows = " num-rows "  numcols = " num-cols)
  
  ;
  ; create the tiles
  ;
  create-tiles num-tiles [
    set hidden? true
    set tile-cover-type "ocean"
    set tile-is-mpa? false
  ]
  
  let tile-list sort tiles
  let k 0
  foreach tile-list [
    ask ? [ 
      set tile-id k
      set k (k + 1)
      set tile-cover-type "land"
      
      set dover-sole-stock-size 0
      set dover-sole-K 1
      set dover-sole-q random-float 0.0
      
      set dover-sole-day-CPUE-mean 0
      set dover-sole-day-CPUE-stdev 0
      set dover-sole-night-CPUE-mean 0
      set dover-sole-night-CPUE-stdev 0
      
      set darkblotched-rockfish-stock-size 0
      set darkblotched-rockfish-K 1
      set darkblotched-rockfish-q 0
      
      set darkblotched-rockfish-day-CPUE-mean 0
      set darkblotched-rockfish-day-CPUE-stdev 0
      set darkblotched-rockfish-night-CPUE-mean 0
      set darkblotched-rockfish-night-CPUE-stdev 0
    ]
  ]
  
  let row-val 0
  let col-val 0
  set k 0
  while [ row-val < num-rows ]
  [
    set col-val 0
    while [ col-val < num-cols ]
    [
      let this-tile one-of tiles with [tile-id = k]
      ask this-tile [
        set tile-row row-val
        set tile-col col-val
      ]
      set col-val (col-val + 1)
      set k (k + 1)
    ]
    set row-val (row-val + 1)
  ]
  
  ;
  ; now read in data
  ;
  set k 0
  while [ not file-at-end? ] [
    ;;print (list "debug: reading record " k " from file...")
    
    ;
    ; read a record
    ;
    let data-tile-id file-read
    let data-tile-row file-read
    let data-tile-col file-read
    let data-cover-type file-read
    
    let data-dover-sole-stock-size file-read
    let data-dover-sole-K file-read
    let data-dover-sole-q file-read
    
    let data-dover-sole-day-CPUE-mean file-read
    let data-dover-sole-day-CPUE-stdev file-read
    let data-dover-sole-night-CPUE-mean file-read
    let data-dover-sole-night-CPUE-stdev file-read
    
    let data-darkblotched-rockfish-stock-size file-read
    let data-darkblotched-rockfish-K file-read
    let data-darkblotched-rockfish-q file-read
    
    let data-darkblotched-rockfish-day-CPUE-mean file-read
    let data-darkblotched-rockfish-day-CPUE-stdev file-read
    let data-darkblotched-rockfish-night-CPUE-mean file-read
    let data-darkblotched-rockfish-night-CPUE-stdev file-read
    
    ;;    print (list "debug: record k= " k )
    ;;    print (list "debug:" data-tile-id data-tile-row data-tile-col data-cover-type
    ;;       
    ;;      data-dover-sole-stock-size data-dover-sole-K data-dover-sole-q 
    ;;      data-dover-sole-day-CPUE-mean data-dover-sole-day-CPUE-stdev 
    ;;      data-dover-sole-night-CPUE-mean data-dover-sole-night-CPUE-stdev  
    ;;           
    ;;      data-darkblotched-rockfish-stock-size  data-darkblotched-rockfish-K data-darkblotched-rockfish-q 
    ;;      data-darkblotched-rockfish-day-CPUE-mean data-darkblotched-rockfish-day-CPUE-stdev 
    ;;      data-darkblotched-rockfish-night-CPUE-mean data-darkblotched-rockfish-night-CPUE-stdev 
    ;;      )
    
    ;
    ; assign values to appropriate tile
    ;
    let this-tile one-of tiles with [ 
      (tile-id = data-tile-id) and 
      (tile-row = data-tile-row) and 
      (tile-col = data-tile-col) ]
    
    ifelse (this-tile != nobody) [
      ask this-tile [
        set tile-id data-tile-id 
        set tile-row data-tile-row 
        set tile-col data-tile-col
        if (data-cover-type = 0) [ set tile-cover-type "ocean" ] 
        if (data-cover-type = 1) [ set tile-cover-type "land" ] 
        
        if (tile-cover-type = "ocean") [
          set dover-sole-stock-size data-dover-sole-stock-size
          set dover-sole-K data-dover-sole-K 
          set dover-sole-q data-dover-sole-q
          set dover-sole-day-CPUE-mean data-dover-sole-day-CPUE-mean
          set dover-sole-day-CPUE-stdev data-dover-sole-day-CPUE-stdev 
          set dover-sole-night-CPUE-mean data-dover-sole-night-CPUE-mean
          set dover-sole-night-CPUE-stdev data-dover-sole-night-CPUE-stdev 
          
          set darkblotched-rockfish-stock-size data-darkblotched-rockfish-stock-size
          set darkblotched-rockfish-K data-darkblotched-rockfish-K 
          set darkblotched-rockfish-q data-darkblotched-rockfish-q 
          set darkblotched-rockfish-day-CPUE-mean data-darkblotched-rockfish-day-CPUE-mean 
          set darkblotched-rockfish-day-CPUE-stdev data-darkblotched-rockfish-day-CPUE-stdev 
          set darkblotched-rockfish-night-CPUE-mean data-darkblotched-rockfish-night-CPUE-mean 
          set darkblotched-rockfish-night-CPUE-stdev data-darkblotched-rockfish-night-CPUE-stdev 
        ]
      ]
    ]
    [
      print (list "DEBUG: warning : can't find tile with tile-row = " data-tile-row " and tile-col = " data-tile-col)
    ]
    set k (k + 1)
  ]
  
  ;
  ; all done
  ;
  file-close 
  
  ;;
  ;; debug
  ;;
  ;;  print (list "debug: just finished reading file... here are contents of tiles ...")
  ;;  foreach sort tiles [
  ;;    ask ? [
  ;;      print (list "tile id = " tile-id "  tile-row " tile-row "  tile-col " tile-col)
  ;;    ]
  ;;  ]
  ;;  print " "
  
  ; ---------------------------------------
  ; now adjust the main map for land-cover 
  ; ---------------------------------------
  let reassigned-dover-sole-stock 0
  let reassigned-darkblotched-rockfish-stock 0
  
  ;
  ; make a list of land grids indicated in the file
  ;
  let file-coastal-grids []
  foreach sort tiles [
    ask ? [
      if tile-cover-type = "land" [
        let g (list ([tile-row] of ?) ([tile-col] of ?))
        set file-coastal-grids fput g file-coastal-grids
      ]
    ]
  ]
  ;; print (list "debug: list of coastal grids from file... " file-coastal-grids)
  
  ;
  ; process the file-indicated land grids
  ;
  foreach file-coastal-grids [
    
    let this-grid-location ?
    let this-grid-row (item 0 this-grid-location)
    let this-grid-col (item 1 this-grid-location)
    let this-grid one-of tiles with [(grid-row = this-grid-row) and (grid-col = this-grid-col) ]
    
    set reassigned-dover-sole-stock 
    (reassigned-dover-sole-stock + ([dover-sole-stock-size] of this-grid))
    
    set reassigned-darkblotched-rockfish-stock 
    (reassigned-darkblotched-rockfish-stock + ([darkblotched-rockfish-stock-size] of this-grid))
    
    ask this-grid [
      set tile-cover-type "land"
      set dover-sole-stock-size 0
      set dover-sole-K 1
      set dover-sole-q 0.0
      
      set dover-sole-day-CPUE-mean 0
      set dover-sole-day-CPUE-stdev 0
      set dover-sole-night-CPUE-mean 0
      set dover-sole-night-CPUE-stdev 0
      
      set darkblotched-rockfish-stock-size 0
      set darkblotched-rockfish-K 1
      set darkblotched-rockfish-q 0
      
      set darkblotched-rockfish-day-CPUE-mean 0
      set darkblotched-rockfish-day-CPUE-stdev 0
      set darkblotched-rockfish-night-CPUE-mean 0
      set darkblotched-rockfish-night-CPUE-stdev 0
    ]
    
    ask patches with [ 
      (grid-row = [grid-row] of this-grid) and 
      (grid-col = [grid-col] of this-grid) ] [
    set cover-type "land"
      ]
  ]
  
  ;
  ; make a list of grids that are known to be land
  ;
  let coastal-grids (list
    (list 9 6) (list 9 7) (list 9 8) (list 9 9)
    (list 8 8) (list 8 9)
    (list 7 9)
    (list 5 9)
    (list 4 9)
    (list 3 7) (list 3 8) (list 3 9)
    (list 2 8) (list 2 9)
    (list 1 9)
    (list 0 8) (list 0 9))
  ;; print (list "debug: list of known coastal grids " coastal-grids) 
  
  ;
  ; process the file-indicated land grids
  ;
  foreach coastal-grids [
    
    let this-grid-location ?
    let this-grid-row (item 0 this-grid-location)
    let this-grid-col (item 1 this-grid-location)
    let this-grid one-of tiles with [(tile-row = this-grid-row) and (tile-col = this-grid-col) ]
    
    ;; print (list "debug: reassigning stock for grid " this-grid-row "  " this-grid-col "...")
    
    set reassigned-dover-sole-stock 
    (reassigned-dover-sole-stock + ([dover-sole-stock-size] of this-grid))
    
    set reassigned-darkblotched-rockfish-stock 
    (reassigned-darkblotched-rockfish-stock + ([darkblotched-rockfish-stock-size] of this-grid))
    
    ask this-grid [
      set tile-cover-type "land"
      set dover-sole-stock-size 0
      set dover-sole-K 1
      set dover-sole-q 0.0
      
      set dover-sole-day-CPUE-mean 0
      set dover-sole-day-CPUE-stdev 0
      set dover-sole-night-CPUE-mean 0
      set dover-sole-night-CPUE-stdev 0
      
      set darkblotched-rockfish-stock-size 0
      set darkblotched-rockfish-K 1
      set darkblotched-rockfish-q 0
      
      set darkblotched-rockfish-day-CPUE-mean 0
      set darkblotched-rockfish-day-CPUE-stdev 0
      set darkblotched-rockfish-night-CPUE-mean 0
      set darkblotched-rockfish-night-CPUE-stdev 0
    ]
    
    ask patches with [ 
      (grid-row = [grid-row] of this-grid) and 
      (grid-col = [grid-col] of this-grid) ] [
    set cover-type "land"
      ]
  ]  
  
  ;
  ; allocate reassigned stock equally across all ocean grids
  ;
  let reallocated-dover-stock 
  (reassigned-dover-sole-stock / (count tiles with [tile-cover-type = "ocean"] ))
  
  let reallocated-rockfish-stock 
  (reassigned-darkblotched-rockfish-stock / (count tiles with [tile-cover-type = "ocean"]))
  
  ask tiles with [cover-type = "ocean"] [
    set dover-sole-stock-size (dover-sole-stock-size + reallocated-dover-stock)
    set darkblotched-rockfish-stock-size (darkblotched-rockfish-stock-size + reallocated-rockfish-stock)
  ]
  
  ;
  ; need to reset ocean patches to baseline state
  ;
  setup-ocean
  
  ;
  ; assign land grids appropriately
  ;
  foreach coastal-grids [
    set row-val item 0 ?
    set col-val item 1 ?
    ask patches with [(grid-row = row-val) and (grid-col = col-val) ]
      [
        set cover-type "land"
        set pcolor green
      ]
  ]
  
  ;
  ; prettify the land grids
  ;
  ask patches with [ cover-type = "land"] [
    let variation random 5
    set pcolor green - 4 + variation
  ]
  
  repeat 3 [
    ask patches with [ cover-type = "land" ] [
      let land-neigbors neighbors with [cover-type = "land"]
      let ave-land-neighbor-color mean [pcolor] of land-neigbors
      set pcolor (pcolor + ave-land-neighbor-color) / 2.0
    ]
  ]
  
  ;
  ; now do some nice fractal coastlines for 
  ; land/water interfaces
  ;
  ; TBD - fix later
  ;
  ask patches with [ cover-type = "land" ]
  [
    
    let spot nobody
    
    ;
    ; coastline on north
    ; patch at dx east dy north
    ;
    set spot patch-at 0 1
    if (spot != nobody) [
      if ([cover-type] of spot) = "ocean" [
        fractal-coast self 0
      ]
    ]
    
    ;
    ; coastline on west
    ;
    set spot patch-at -1 0
    if (spot != nobody) [
      if ([cover-type] of spot) = "ocean" [
        fractal-coast self 270       
      ]
    ]
    
    ;
    ; coastline on south
    ;
    set spot patch-at 0 -1
    if (spot != nobody) [
      if ([cover-type] of spot) = "ocean" [
        fractal-coast self 180
      ]
    ]
    
    ;
    ; coastline on east
    ;
    set spot patch-at 1 0
    if (spot != nobody) [
      if ([cover-type] of spot) = "ocean" [
        fractal-coast self 90
      ]
    ]      
  ]
  
end

; fractal-coast
;
; TBD - make a nice fractal coastline for 
; the patch edges
;
to fractal-coast [ p direction ]
  ; if (direction = 0) [
  ; ask p [ set pcolor orange ]
  ; ]
  ;  
  ;  if (direction = 270) [
  ;    ask p [ set pcolor orange ]
  ;  ]
  ;  
  ;  if (direction = 180) [
  ;    ask p [ set pcolor orange ]
  ;  ]
  ;  
  ;  if (direction = 90) [
  ;    ask p [ set pcolor orange ]
  ; ]
end

; setup-boats
;
; setup the fleet
;
to setup-boats
  ;
  ; define where the boats start and end from
  ;
  set harbor-spots nobody
  ask patches with [cover-type = "harbor"] [
    set harbor-spots patches in-radius 3 with [cover-type = "ocean"]
  ]
  
  ;
  ; create the fleet
  ;
  create-boats fleet-size [
    set color orange
    set shape "square"
    set size 0.5
    
    let chosen-spot one-of harbor-spots
    let xpos [pxcor] of chosen-spot
    let ypos [pycor] of chosen-spot
    setxy xpos ypos
    
    ;
    ; setup all the fishing trip parameters
    ;
    set trip-phase "in-port"
    
    ;
    ; set up preferred grids (avoid MPAs if they are active)
    ifelse (MPAs-active? = false) [
      set preferred-grids []
      set preferred-grids (n-of (1 + random 5) [tile-id] of tiles with [tile-cover-type = "ocean"])
      set preferred-grids sort preferred-grids
    ]
    [
      set preferred-grids []
      let num-grids 2 + random 5
      let candidate-grids [tile-id] of tiles with [tile-cover-type = "ocean"]
      foreach MPA-TILE-LIST [
        set candidate-grids (remove ? candidate-grids)
      ]
      foreach sequence 0 num-grids 1 [
        let spot one-of candidate-grids
        set preferred-grids (fput spot preferred-grids)
        set candidate-grids (remove spot candidate-grids)
      ]
      
      set preferred-grids sort preferred-grids
    ]
    
    set current-trip []
    set trip-history []
    set catch-history []
    set dover-catch 0
    set rockfish-catch 0
    
    let BOAT-BASE-WEALTH 50000
    set wealth precision (BOAT-BASE-WEALTH + (random-normal BOAT-BASE-WEALTH 20000)) 2
    
    set cost-factor precision (random-normal 1.0 0.5) 2
    set effort 1 + random 4
    
    ;
    ; create first trip
    ;
    let grid-id-val (one-of preferred-grids)
    let start-time-val 0 + random 5
    let end-time-val start-time-val + 1 + random 4
    let planned-effort-val 2 * (end-time-val - start-time-val)
    let dover-catch-val 0
    let rockfish-catch-val 0
    set current-trip (create-new-trip 
      grid-id-val 
      start-time-val end-time-val 
      planned-effort-val 
      dover-catch-val rockfish-catch-val )
  ]
end

; setup
;
; setup the simulation
;
to setup
  clear-all
  setup-globals
  setup-landscape
  setup-tiles
  setup-harbors
  setup-boats
  
  if (MPAs-active? = true) [
    setup-mpa
  ]
  
  render-plots
  reset-ticks
end



; render-plots
;
; used to update plots on user screen
;
to render-plots
  render-dover-plot
  render-rockfish-plot
end

; render-dover-plot
;
; display "heatmap" of dover sole abundance
;
to render-dover-plot
  set-current-plot "dover-density"
  clear-plot
  set-current-plot-pen "density-pen"
  let x-list sequence 0 9 1
  let y-list sequence 0 9 1
  
  foreach x-list [
    let xpos ?
    foreach y-list [
      let ypos ?
      set-current-plot-pen "density-pen"
      
      ;
      ; select the correct tile to render
      ;
      let tile-set tiles with [ (tile-row = xpos) and (tile-col = ypos) ]
      let this-tile one-of tile-set ; should always be only 1 tile selected !
      
                                    ;
                                    ; figure out what color based on stock density
                                    ;
                                    ; let gray   = no density           0%
                                    ; let red    = low density          0% to 24%
                                    ; let orange = medium low density   25% to 49%
                                    ; let yellow = med high density     50% to 74%
                                    ; let green  = high density         75% to 100%      
      
      let tile-density ( 
        ([dover-sole-stock-size] of this-tile ) / ( [dover-sole-K] of this-tile))
      
      if ( tile-density = 0.0) [
        set-plot-pen-color gray + 2
      ]      
      if ( tile-density > 0.0 and tile-density <= 0.25 ) [
        set-plot-pen-color red
      ]
      if ( tile-density > 0.25 and tile-density <= 0.50 ) [
        set-plot-pen-color orange
      ]      
      if ( tile-density > 0.50 and tile-density <= 0.75 ) [
        set-plot-pen-color yellow
      ]
      if ( tile-density > 0.75 and tile-density <= 1.00 ) [
        set-plot-pen-color green
      ]
      
      ;print (list "debug: rendering DOVER grid " tile-row " - " tile-col "  density = " precision tile-density 2)
      ;
      ; now draw a little box centered around xpos - ypos
      ;
      let xvals sequence (xpos + 0.5 - 0.3) (xpos + 0.5 + 0.3) 0.1
      let yvals sequence (ypos + 0.5 - 0.3) (ypos + 0.5 + 0.3) 0.1
      foreach xvals [
        let x ?
        foreach yvals [
          let y ?
          plotxy y x
        ]
      ]
    ]
  ]
end

; render-rockfish-plot
;
; display "heatmap" of rockfish abundance
;
to render-rockfish-plot
  set-current-plot "rockfish-density"
  clear-plot
  set-current-plot-pen "density-pen"
  let x-list sequence 0 9 1
  let y-list sequence 0 9 1
  
  foreach x-list [
    let xpos ?
    foreach y-list [
      let ypos ?
      set-current-plot-pen "density-pen"
      
      ;
      ; select the correct tile to render
      ;
      let tile-set tiles with [ (tile-row = xpos) and (tile-col = ypos) ]
      let this-tile one-of tile-set ; should always be only 1 tile selected !
      
                                    ;
                                    ; figure out what color based on stock density
                                    ;
                                    ; let gray   = no density           0%
                                    ; let red    = low density          0% to 24%
                                    ; let orange = medium low density   25% to 49%
                                    ; let yellow = med high density     50% to 74%
                                    ; let green  = high density         75% to 100%    
      
      let tile-density ( 
        ([darkblotched-rockfish-stock-size] of this-tile ) / ( [darkblotched-rockfish-K] of this-tile))
      
      if ( tile-density = 0.0) [
        set-plot-pen-color gray + 2
      ]   
      if ( tile-density > 0.0 and tile-density <= 0.25 ) [
        set-plot-pen-color red
      ]
      if ( tile-density > 0.25 and tile-density <= 0.50 ) [
        set-plot-pen-color orange
      ]      
      if ( tile-density > 0.50 and tile-density <= 0.75 ) [
        set-plot-pen-color yellow
      ]
      if ( tile-density > 0.75 and tile-density <= 1.00 ) [
        set-plot-pen-color green
      ]
      
      ;print (list "debug: rendering ROCKFISH grid " tile-row " - " tile-col "  density = " precision tile-density 2)
      
      ;
      ; now draw a little box centered around xpos - ypos
      ;
      let xvals sequence (xpos + 0.5 - 0.3) (xpos + 0.5 + 0.3) 0.1
      let yvals sequence (ypos + 0.5 - 0.3) (ypos + 0.5 + 0.3) 0.1
      foreach xvals [
        let x ?
        foreach yvals [
          let y ?
          plotxy y x
        ]
      ]
    ]
  ]
end

; sim-timekeeping
;
; manage various timekeeping variables
;
to sim-timekeeping
  set day day-num
  set month month-num
  set year year-num
  set julian-day julian-day-num
  
  ;
  ; update season and trigger spawing time if appropriate
  ;
  set previous-season season
  set season season-name
  ifelse (previous-season = "spring") and (season = "summer") [
    set spawning-time? true
  ]
  [
    set spawning-time? false
  ]
  
  ;
  ; update new-month flag for fish movement
  ;
  ifelse (day-num = 1) [
    set new-month? true
  ]
  [
    set new-month? false
  ]
end


; fish-grow
;
; simulates change in biomass due to fish spawning and natural growth
; increase occurs at the beginning of the summer season to account
; for growth and spawn during the spring
;
; at all other times  no action occurs
;
to fish-grow
  if (spawning-time? = true) [
    ask tiles [
      ;
      ; grow the dover sole
      ;
      let dover-stock [dover-sole-stock-size] of self
      let dover-K     [dover-sole-K] of self
      let dover-spawn (dover-sole-r * dover-stock) * (1.0 - (dover-stock / dover-K))
      set dover-sole-stock-size (dover-stock + dover-spawn)
      
      ;
      ; grow the rockfish
      ;
      let rockfish-stock [darkblotched-rockfish-stock-size] of self
      let rockfish-K     [darkblotched-rockfish-K] of self
      let rockfish-spawn (darkblotched-rockfish-r * rockfish-stock) * (1.0 - (rockfish-stock / rockfish-K))
      set darkblotched-rockfish-stock-size (rockfish-stock + rockfish-spawn)
    ]
    
    ; reset for next year
    set spawning-time? false
  ]
  
end

; fish-move
;
; simulates a little bit of stock drift due to fish movement.
; at the beginning of each month  a small percentage of fish
; may move from their current tile to an adjacent tile.
;
; at all other times  no action occurs.
;
; note: this is not working - recommend disabling for now
; and doing more debugging later
;
to fish-move
  if (new-month? = true) [
    
    ;
    ; test to make sure tiles are in a consistent state first...
    ;
    
    let dover-stocks sort [dover-sole-stock-size] of tiles
    let rockfish-stocks sort [darkblotched-rockfish-stock-size] of tiles
    
    let row-vals sequence 0 9 1
    let col-vals sequence 0 9 1
    let dover-faults []
    let rockfish-faults []
    
    foreach row-vals [
      let row-num ?
      foreach col-vals [
        let col-num ?
        let grid-list tiles with [ (tile-row = row-num) and (tile-col = col-num) ]
        let grid-item one-of grid-list
        if [dover-sole-stock-size] of grid-item < 0 [
          set dover-faults fput [tile-id] of grid-item dover-faults
        ]
        if [darkblotched-rockfish-stock-size] of grid-item < 0 [
          set rockfish-faults fput [tile-id] of grid-item rockfish-faults
        ]
      ]
    ]
    let flag-error? false
    if (length dover-faults) > 0 [
      print (list "debug: detected dover-sole-stock-size faults in grids " dover-faults)
      set flag-error? true
    ]
    if (length rockfish-faults) > 0 [
      print (list "debug: detected darkblotched-rockfish-stock-size faults in grids " rockfish-faults)
      set flag-error? true
    ]
    if (flag-error? = true) [
      user-message (word "WARNING: stock-size fault detected")
    ]
    
    
    ask tiles [
      let near-tiles moore-neighbors-tiles self
      
      print " "
      print " ========================================================== "
      print (list "debug: moore neighbor of tiles for src-tile = " [tile-id] of self " = " 
        (sort ([tile-id] of near-tiles)))
      
      let chosen-tile one-of near-tiles with [tile-cover-type = "ocean"]
      if ((chosen-tile != nobody) and (chosen-tile != self)) [
        
        print (list "debug: swapping src-tile = " tile-id "  tgt-tile = " [tile-id] of chosen-tile)
        
        ;
        ; compute stock swap amounts
        ;
        let DOVER-SWAP-RATE 0.01
        let ROCKFISH-SWAP-RATE 0.01
        
        let dover-swap-amt DOVER-SWAP-RATE * dover-sole-stock-size
        let rockfish-swap-amt ROCKFISH-SWAP-RATE * darkblotched-rockfish-stock-size
        
        ;
        ; test to see if OK to swap
        ;
        let ok-to-swap? false
        if ((dover-sole-stock-size - dover-swap-amt) > 0) 
        and ((darkblotched-rockfish-stock-size - rockfish-swap-amt) > 0) [
          set ok-to-swap? true
        ]
        
        print (list "debug: ok-to-swap? = " ok-to-swap?)
        
        ;
        ; swap if OK
        ;
        if (ok-to-swap? = true) [
          print " "
          print (list "BEFORE src-dover = " precision dover-sole-stock-size 2
            "  src-rockfish = " precision darkblotched-rockfish-stock-size 2
            "  tgt-dover    = " precision [dover-sole-stock-size] of chosen-tile 2
            "  tgt-rockfish = " precision [darkblotched-rockfish-stock-size] of chosen-tile 2)
          
          ;
          ; decrement our stock
          ;
          set dover-sole-stock-size (dover-sole-stock-size - dover-swap-amt)
          set darkblotched-rockfish-stock-size (darkblotched-rockfish-stock-size - rockfish-swap-amt)
          
          ;
          ; increment neighbor stock
          ;
          ask chosen-tile [
            set dover-sole-stock-size (dover-sole-stock-size + dover-swap-amt)
            set darkblotched-rockfish-stock-size (darkblotched-rockfish-stock-size + rockfish-swap-amt)
          ]
          
          print (list "AFTER  src-dover = " precision dover-sole-stock-size 2
            "  src-rockfish = " precision darkblotched-rockfish-stock-size 2
            "  tgt-dover    = " precision [dover-sole-stock-size] of chosen-tile 2
            "  tgt-rockfish = " precision [darkblotched-rockfish-stock-size] of chosen-tile 2)
          
          if (dover-sole-stock-size < 0) or 
          (darkblotched-rockfish-stock-size < 0) or
          ([dover-sole-stock-size] of chosen-tile < 0) or
          ([darkblotched-rockfish-stock-size] of chosen-tile < 0) [
            
            print (list "********************************************************")
            print (list "*                                                      *")
            print (list "*           WARNING: negative value detected           *") 
            print (list "*                                                      *")
            print (list "********************************************************")
            
            user-message (word "WARNING: negative value detected")    
          ]
          
        ]          
      ]
    ]
    
    ;
    ; reset so fish only move once a month
    ;
    set new-month? false
    
  ]
end

; boats-select-best-spot
;
; method to analyze trip history and determine which spot
; was the best spot so far (only looks at Dover catches)
;
to-report boats-select-best-location
  let best-location 0
  let sorted-catch-history set-catch-history-sum catch-history
  let max-item []
  let max-catch 0
  foreach sorted-catch-history [
    let this-item ?
    let this-catch (sum (list ((item 1 this-item) + (item 2 this-item))))
    if this-catch > max-catch [
      set max-item this-item
      set max-catch this-catch
    ]
  ]
  
  ifelse (max-item = []) [
    print (list "debug: SERIOUS WARNING: boat " self " unable to find best location from catch-history = " catch-history)
  ]
  [
    set best-location (item 0 max-item)
  ]
  report best-location
end

; boats-select-worst-spot
;
;
; method to analyze trip history and determine which spot
; was the worst spot so far (only looks at Dover catches)
; 
; this is used to trim the preferred spot list
;
to-report boats-select-worst-location
  let worst-location 0
  let sorted-catch-history set-catch-history-sum catch-history
  let min-item []
  let min-catch 1.0E20
  foreach sorted-catch-history [
    let this-item ?
    let this-catch (sum (list ((item 1 this-item) + (item 2 this-item))))
    if this-catch < min-catch [
      set min-item this-item
      set min-catch this-catch
    ]
  ]
  set worst-location (item 0 min-item)
  report worst-location
end

;;; boats-select-best-spot
;;;
;;; method to analyze trip history and determine which spot
;;; was the best spot so far (only looks at Dover catches)
;;;
;;to-report boats-select-best-spot-OLD
;;  let best-spot 0
;;  
;;  ;
;;  ; select the best spot we've seen so far and use that as the trip location
;;  ;
;;  
;;  ;
;;  ; first, let's make a hash table of key:value pairs
;;  ; using the location as the key and the dover-catch as the value
;;  ; 
;;  let location-catch-hash []
;;  foreach trip-history [
;;    let trip ?
;;    let key (get-trip-destination trip)
;;    let value (get-trip-dover-catch trip)
;;    let key-value-pair (list key value)
;;    set location-catch-hash (fput key-value-pair location-catch-hash)
;;  ]
;;  
;;  ;
;;  ; now let's sort the location-catch-hash in order by locations
;;  ;
;;  set location-catch-hash (sort-by [item 0 ?1 < item 0 ?2] location-catch-hash)
;;  
;;  ;
;;  ; now let's accumulate all the catches at a location
;;  ;
;;  let location-list []
;;  foreach location-catch-hash [
;;    let data ?
;;    let location (item 0 data)
;;    set location-list (fput location location-list)
;;  ]
;;  set location-list sort remove-duplicates location-list
;;  
;;  ;
;;  ; now let's compute the location with the best catch so far
;;  ;
;;  let max-location -1
;;  let max-catch -1
;;  foreach location-list [
;;    let data ?
;;    
;;    ; get all the entries for this location from the location-catch-hash
;;    let location-records filter [ first ? = data ] location-catch-hash
;;    
;;    let tmp-sum 0
;;    foreach location-records [
;;      set tmp-sum (tmp-sum + (item 1 ?))
;;      if (tmp-sum > max-catch) [
;;        set max-catch tmp-sum
;;        set max-location (item 0 ?)
;;      ]
;;    ]
;;    
;;    set best-spot max-location
;;  ]
;;  
;;  ; check to make sure tile is legitimate ocean patch !
;;  if [tile-cover-type] of get-tile-id best-spot = "land" [
;;    print (list "ERROR: trying to fish on land patch with tile-id = " best-spot)
;;    user-message (word "ERROR: trying to fish on land patch")
;;  ]
;;  
;;  report best-spot
;;end


; boats-compute-predicted-results
;
; utility method used by boats to assess their
; anticipated catch, cost, and profits for all of
; their current preferred spots
;
to-report boats-compute-predicted-results
  let prediction-list []
  
  foreach preferred-grids [
    let grid-id ?
    let estimated-total-profit 0
    let estimated-dover-catch 0
    let estimated-dover-cost 0
    let estimated-dover-effort 0
    let estimated-dover-profit 0
    let estimated-rockfish-catch 0
    let estimated-rockfish-cost 0
    let estimated-rockfish-effort 0
    let estimated-rockfish-profit 0 
    
    ;
    ; estimate the catch
    ;
    ; if we have catch history from this grid-id, use that
    ; otherwise make a rough estimate using a percentage of TAC
    ;
    let prior (filter [ first ? = grid-id ] trip-history)
    ifelse ((length prior) > 0)  [
      let prior-data item 0 prior
      set estimated-dover-catch max (list (item 1 prior-data) 1.0)    ; avoid div by 0 possiblity if 0 historical catch
      set estimated-rockfish-catch max (list (item 2 prior-data) 1.0) ; avoid div by 0 possiblity if 0 historical catch
    ]
    [
      set estimated-dover-catch 0.01 * ( dover-TAC / (count tiles) ) 
      set estimated-rockfish-catch 0.01 * (rockfish-TAC / (count tiles) )     
    ]
    
    ;
    ; estimate the trip cost
    ;
    ; use cartesian distance to selected site multiplied by a cost factor to represent
    ; cost of fuel, supplies, and other expenses.
    ;
    let total-trip-cost 0
    let target-spot nobody
    ask tiles with [tile-id = grid-id] [ set target-spot one-of tile-patch-set]
    let harbor-spot one-of patches with [cover-type = "harbor"] 
    let cartesian-distance 0
    ask harbor-spot [ set cartesian-distance distance target-spot ]
    let cost-per-nautical-mile 0.25
    set estimated-dover-cost precision ( cost-per-nautical-mile * cartesian-distance ) 2
    set estimated-rockfish-cost precision ( cost-per-nautical-mile * cartesian-distance) 2
    
    ;
    ; estimate effort as days-at-sea
    ;
    ; use data from aggregated log data set "Trip Summaries.xlsx"
    ; which compiled OR and Astoria data from 2003-2013
    ;
    let mean-tows-per-trip random-normal 6.1545 2.1452
    set mean-tows-per-trip (max (list 1.0 mean-tows-per-trip)) ; ensure at least one tow occurs
    ;; let mean-trip-duration-days random-normal 2.2886 0.5439
    set estimated-dover-effort round mean-tows-per-trip
    set estimated-rockfish-effort round mean-tows-per-trip
    
    
    ;
    ; computed estimated profit based on assumed catch, quota costs, and 
    ; estimated operations costs
    ;
    set estimated-dover-profit precision 
    (((estimated-dover-catch * (dover-landing-price-per-lb - average-dover-quota-price)) - estimated-dover-cost) /
    estimated-dover-effort) 2
    
    set estimated-rockfish-profit precision 
    (((estimated-rockfish-catch * (rockfish-landing-price-per-lb - average-rockfish-quota-price)) - estimated-rockfish-cost) /
    estimated-rockfish-effort) 2    
    

    ;
    ; create an entry in the prediction table
    ;
    set estimated-total-profit precision (estimated-dover-profit + estimated-rockfish-profit) 2
    let prediction (list grid-id estimated-total-profit 
      estimated-dover-catch estimated-dover-cost 
      estimated-dover-effort estimated-dover-profit  
      estimated-rockfish-catch estimated-rockfish-cost 
      estimated-rockfish-effort estimated-rockfish-profit )
    
    set prediction-list (fput prediction prediction-list) 
  ]
  
  report prediction-list
end

; boats-operate
;
; simulates boats doing fishing operations
;
to boats-operate
  ;
  ; if we're at the start of a new year, reset all
  ; the ITQ management vars
  ;
  if ((month-num = 1) and (day-num = 1)) [
    ask boats [

      set dover-catch 0
      set rockfish-catch 0
      
      set dover-TAC-share precision (1 / fleet-size ) 2
      set rockfish-TAC-share precision ( 1 / fleet-size ) 2
      
      set dover-quota precision ( dover-TAC-share * Dover-TAC ) 2
      set rockfish-quota precision ( rockfish-TAC-share * Rockfish-TAC) 2
      
      set dover-quota-price 1
      set rockfish-quota-price 1
      
      set amt-dover-quota-remaining dover-quota
      set amt-rockfish-quota-remaining rockfish-quota
      
      set amt-dover-quota-needed 0
      set amt-rockfish-quota-needed 0
      
      set predicted-results []
      set best-spot nobody
      set highest-profit 0
      
      set gDover 0.0
      set gRockfish 0.0
    ]
    print (list "debug: all boats successfully reset quota for new year " year-num)
  ]
  
  ;
  ; check to see if we're running ITQs
  ; if so, do the ITQ logic
  ; if not, do the conventional logic
  ;
  ifelse (ITQs-active? = true) [
    boats-operate-ITQs
  ]
  [
    boats-operate-non-ITQs
  ]
  
  ;
  ; check to see if we've gone below the minimum
  ; value for bankrupcy
  ;
  ask boats [
    if wealth < -100000 [
      print (list "debug: boat " self month-num ":" day-num ":" year-num " has gone bankrupt, net weath = " 
        precision wealth 2
        )
      die
    ]
  ]
end

; boats-operate-ITQs
;
; simulate ITQ operations with trading
;
to boats-operate-ITQs
  
  ;
  ; compute fishery wide price points
  ;
  set average-dover-quota-price ((sum [dover-quota-price] of boats) / fleet-size )
  set average-rockfish-quota-price ((sum [rockfish-quota-price] of boats) / fleet-size )
    
  ; ===================================================================
  ;
  ; check for seasonal closure, return to port if still out fishing
  ; during a closing season
  ;
  ; ===================================================================
  let OK-to-fish? true
  if (seasonal-closure? = true) [
    if (member? month-num SEASONAL-CLOSURE-LIST) [
      set OK-to-fish? false
    ] 
  ]
  
  
  ifelse (not OK-to-fish?) [
    ;  =========================================
    ;
    ; season is closed, not OK to fish...
    ; bring any boats out at sea back home ASAP
    ;
    ;  =========================================
    ask boats [
      set trip-phase "in-port"
      set current-trip []
      move-to one-of harbor-spots
    ]
  ]
  [
    ; =========================================
    ;
    ; season is open, it's OK to fish ...
    ;
    ; =========================================
    
    ask boats [
      ;
      ; based on trip phase, figure out what to do
      ;
            
      ; ---------------------------------------------
      ;
      ; in port
      ;     
      ; ---------------------------------------------
      if (trip-phase = "in-port") [
        ;
        ; do all your calculations RE: ITQ trading
        ;
        
        ;
        ; first compute our expected outcomes from all our preferred spots
        ;
        set predicted-results boats-compute-predicted-results
        
        ;; print (list "debug: predicted results for boat " self " = " predicted-results)
        
        ;
        ; now determine which is our predicted best spot and how much profit to expect
        ;
        set predicted-results sort-by [ item 1 ?1 > item 1 ?2 ] predicted-results
        let best-predicted-spot (first predicted-results)
        set best-spot (item 0 best-predicted-spot)
        set highest-profit (item 1 best-predicted-spot)
        
        ;; print (list "debug: best predicted results for boat " self " = " best-predicted-spot) 
        
        ;
        ; now compute our gDover and gRockfish values
        ;
        let expected-dover-catch item 2 best-predicted-spot
        let expected-dover-cost item 3 best-predicted-spot
        set gDover ((dover-landing-price-per-lb * expected-dover-catch ) - expected-dover-cost ) 
        / expected-dover-catch
        
        let expected-rockfish-catch item 6 best-predicted-spot
        let expected-rockfish-cost item 7 best-predicted-spot
        set gRockfish ((rockfish-landing-price-per-lb * expected-rockfish-catch ) - expected-rockfish-cost ) 
        / expected-rockfish-catch  
        
        ;; print (list "debug: boat " self "gDover = " precision gDover 2 ", gRockfish = " precision gRockfish 2) 
        
        ;
        ; now figure out if we need to do any trading to achieve our best spot
        ;
        if (highest-profit > 0) [
          
          ;
          ; do we need Dover quota?
          ;
          if (expected-dover-catch > amt-dover-quota-remaining) [
            set amt-dover-quota-needed precision (expected-dover-catch - amt-dover-quota-remaining) 2
            ;;print (list "debug: boat " self " needs dover quota, amt = " amt-dover-quota-needed)
          ]
          
          ;
          ; do we need Rockfish quota?
          ;
          if (expected-rockfish-catch > amt-rockfish-quota-remaining) [
            set amt-rockfish-quota-needed precision (expected-rockfish-catch - amt-rockfish-quota-remaining) 2
            ;;print (list "debug: boat " self " needs rockfish quota, amt = " amt-rockfish-quota-needed)
          ] 
          
          ;
          ; do we need to trade for Dover quota?
          ;
          if (amt-dover-quota-needed > 0) [
            let potential-dover-quota-sellers boats with [ 
              ; (dover-quota > [amt-dover-quota-needed] of self) and (gDover < [gDover] of self) ]
              (amt-dover-quota-remaining > [amt-dover-quota-needed] of self) ]
            
            ;;print (list "debug: boat " self " has these potential dover sellers " potential-dover-quota-sellers)
            
            if (count potential-dover-quota-sellers > 0) [
              let dover-seller one-of potential-dover-quota-sellers
              
              ;;print (list "debug: boat " self " buying dover quota from boat " dover-seller) 
              
              ; compute the prices
              let min-price min (list ([gDover] of dover-seller) ([gDover] of self))
              let max-price max (list ([gDover] of dover-seller) ([gDover] of self))
              let closing-price (min-price + random-float (max-price - min-price))
              set dover-quota-price closing-price
              
              ; do the transfer 
              let wealth-transfer (closing-price * amt-dover-quota-needed)
              if ((wealth - wealth-transfer) > 0) [
                set wealth (wealth - wealth-transfer)
                ask dover-seller [set wealth (wealth + wealth-transfer)]
                
                set amt-dover-quota-remaining (amt-dover-quota-remaining + amt-dover-quota-needed)
                set amt-dover-quota-needed 0
                ask dover-seller [set amt-dover-quota-remaining (amt-dover-quota-remaining - amt-dover-quota-needed)]
              ]
            ]
          ]
          
          ;
          ; do we need to trade for Rockfish quota?
          ;
          if (amt-rockfish-quota-needed > 0) [
            let potential-rockfish-quota-sellers boats with [ 
              ; (rockfish-quota > [amt-rockfish-quota-needed] of self) and (gRockfish < [gRockfish] of self) ]
              (amt-rockfish-quota-remaining > [amt-rockfish-quota-needed] of self) ]
                      
            ;;print (list "debug: boat " self " has these potential rockfish sellers " potential-rockfish-quota-sellers)
            
            if (count potential-rockfish-quota-sellers > 0) [
              let rockfish-seller one-of potential-rockfish-quota-sellers
              
              ;;print (list "debug: boat " self " buying rockfish quota from boat " rockfish-seller) 
              
              ; compute the prices
              let min-price min (list ([gRockfish] of rockfish-seller) ([gRockfish] of self))
              let max-price max (list ([gRockfish] of rockfish-seller) ([gRockfish] of self))
              let closing-price (min-price + random-float (max-price - min-price))
              set rockfish-quota-price closing-price
              
              ; do the transfer 
              let wealth-transfer (closing-price * amt-rockfish-quota-needed)
              if ((wealth - wealth-transfer) > 0) [
                set wealth (wealth - wealth-transfer)
                ask rockfish-seller [set wealth (wealth + wealth-transfer)]
                
                set amt-rockfish-quota-remaining (amt-rockfish-quota-remaining + amt-rockfish-quota-needed)
                set amt-rockfish-quota-needed 0
                ask rockfish-seller [set amt-rockfish-quota-remaining (amt-rockfish-quota-remaining - amt-rockfish-quota-needed)]
              ]
            ]
          ]
          
          ;
          ; done trading, did everything work out?
          ;
          ifelse ((amt-dover-quota-needed = 0) and (amt-rockfish-quota-needed = 0)) [
            
            ;
            ; yes, OK to proceed.  Create a trip to selected location
            ;
            
            ;
            ;
            ; setup trip parameters
            ;
            let grid-id-val best-spot
            let start-time-val ticks + random 5                        ; start sometime in next 5 days
            let end-time-val start-time-val + 1 + random 4             ; trip is 1 to 4 days long
            let planned-effort-val 2 * (end-time-val - start-time-val) ; assume 2 tows of effort per day
            let dover-catch-val 0
            let rockfish-catch-val 0
            
            ;
            ; create a new trip
            ;
            set current-trip (create-new-trip 
              grid-id-val 
              start-time-val end-time-val 
              planned-effort-val dover-catch-val rockfish-catch-val )
          
            ;
            ; now check to see if it's time to sail yet
            ;
            if ((get-trip-start-time current-trip) = ticks) [
              set trip-phase "outward-bound"
            ]
          ]
          [
            ;
            ; not OK, must stay in port
            ;
            set trip-phase "in-port"
            print (list "debug: boat " self " " month-num ":" day-num ":" year-num " can't fish, unable to obtain " 
              amt-dover-quota-needed " dover quota, " 
              amt-rockfish-quota-needed " rockfish quota")       
          ]
        ]
      ]
      
      ; ---------------------------------------------
      ;
      ; outward bound
      ;     
      ; ---------------------------------------------
      if (trip-phase = "outward-bound") [
        ;
        ; select a patch location in current trip preferred tile
        ;
        let spot one-of [tile-patch-set] of get-tile-id get-trip-destination current-trip
        move-to spot
        set trip-phase "on-station"
        set effort (get-trip-effort current-trip)     ; keep track of our projected trip cost
      ]
      
      
      ; ---------------------------------------------
      ;
      ; on-station
      ;     
      ; ---------------------------------------------
      if (trip-phase = "on-station") [
        ; 
        ; compute how much effort is remaining for this trip
        ;
        let remaining-effort ( get-trip-effort current-trip )
        
        ;
        ; if we still have planned effort, continue to fish
        ;
        ifelse (remaining-effort > 0) [
          boats-fish ( get-tile-id (get-trip-destination current-trip) )
          
          if (dover-catch < 0) [
            print (list "debug: warning: boat " self " reports negative dover catch " dover-catch)
          ]
          if (rockfish-catch < 0) [
            print (list "debug: warning: boat " self " reports negative rockfish catch " rockfish-catch)
          ]          
          
          let prev-dover-catch precision ( get-trip-dover-catch current-trip ) 2
          let prev-rockfish-catch precision ( get-trip-rockfish-catch current-trip ) 2
          
          set current-trip ( set-trip-dover-catch current-trip precision (dover-catch + prev-dover-catch) 2 )
          set current-trip ( set-trip-rockfish-catch current-trip precision (rockfish-catch + prev-rockfish-catch) 2 )
          
          set remaining-effort (remaining-effort - 1)
          set current-trip ( set-trip-effort current-trip remaining-effort )
          
          set dover-catch 0
          set rockfish-catch 0
        ]
        [
          ;
          ; all done, head for home
          ;
          set trip-phase "homeward-bound"
        ]
      ]
      
      
      ; ---------------------------------------------
      ;
      ; homeward bound
      ;     
      ; ---------------------------------------------
      if (trip-phase = "homeward-bound") [
        let spot one-of harbor-spots
        move-to spot
        set trip-phase "in-port"
        
        ;
        ; compute economic results of this trip
        ;
        set wealth (wealth + (get-trip-dover-catch current-trip) + (get-trip-rockfish-catch current-trip))
        
        ;
        ; compute changes in ITQ budgets from this trip
        ;
        set amt-dover-quota-remaining (amt-dover-quota-remaining - (get-trip-dover-catch current-trip))
        if (amt-dover-quota-remaining < 0) [
          set amt-dover-quota-needed (abs amt-dover-quota-remaining)
          set amt-dover-quota-remaining 0
        ]        
        set amt-rockfish-quota-remaining (amt-rockfish-quota-remaining - (get-trip-rockfish-catch current-trip))
        if (amt-rockfish-quota-remaining < 0) [
          set amt-rockfish-quota-needed (abs amt-rockfish-quota-remaining)
          set amt-rockfish-quota-remaining 0
        ]
        
        ; =============================================
        ; 
        ; check for presence of landing taxes
        ;
        ; =============================================
        let landing-tax-amount 0
        let cost-per-tow 50.0
        let operating-costs (effort * cost-per-tow )
        if (landing-taxes? = true) [
          set landing-tax-amount LANDING-TAX-RATE * (get-trip-dover-catch current-trip)
        ]
        set wealth precision (wealth - ( operating-costs + landing-tax-amount )) 2
        
        ;
        ; keep track of our trip history
        ; zero out current trip so we can plan for the next trip
        ;
        
        ; check to make sure current-trip data is OK
        if ((get-trip-dover-catch current-trip) < 0) [
          print (list "debug: warning: boat " self " has faulty current trip, dover-catch < 0 " current-trip)
        ]
        if ((get-trip-rockfish-catch current-trip) < 0) [
          print (list "debug: warning: boat " self " has faulty current trip, rockfish-catch < 0 " current-trip)
        ]  
        
        set trip-history ( fput current-trip trip-history )
        
        set catch-history (fput 
          (list 
            (get-trip-destination current-trip) 
            (get-trip-dover-catch current-trip) 
            (get-trip-rockfish-catch current-trip)) catch-history)
        
        ;;print (list "debug: before accumulation - catch history for boat " self " = " catch-history)
        set catch-history ( set-catch-history-mean catch-history )
        ;;print (list "debug: after accumulation - catch history for boat " self " = " catch-history)
        
        set current-trip []
      ]
    ]
  ]
  
end


; boats-operate-non-ITQs
;
; simulate "conventional" operations without ITQ trading
;
to boats-operate-non-ITQs
  
  ; ===================================================================
  ;
  ; check for seasonal closure, return to port if still out fishing
  ; during a closing season
  ;
  ; ===================================================================
  let OK-to-fish? true
  if (seasonal-closure? = true) [
    if (member? month-num SEASONAL-CLOSURE-LIST) [
      set OK-to-fish? false
    ] 
  ]
  
  
  ifelse (not OK-to-fish?) [
    ;  =========================================
    ;
    ; season is closed, not OK to fish...
    ; bring any boats out at sea back home ASAP
    ;
    ;  =========================================
    ask boats [
      set trip-phase "in-port"
      set current-trip []
      move-to one-of harbor-spots
    ]
  ]
  [
    ; =========================================
    ;
    ; season is open, it's OK to fish ...
    ;
    ; =========================================
    
    ask boats [
      
      
      ;
      ; based on trip phase, figure out what to do
      ;

      
      ; ---------------------------------------------
      ;
      ; in port
      ;     
      ; ---------------------------------------------
      if (trip-phase = "in-port") [
        
        ;;print (list "debug: current-trip for boat " self " = " current-trip )
        
        ;
        ; if you don't have a next trip, make one
        ;
        if (length current-trip = 0) [
                    
          ; declare some vars used for trips
          let grid-id-val 0
          
          
          ;
          ; if we have not fished a few trips, just create a new trip
          ;
          ifelse (length trip-history < (3 * length preferred-grids)) [
            ;
            ; create a new trip selecting a spot randomly from our preferred list
            ;
            set grid-id-val (one-of shuffle preferred-grids)
          ]
          [
            ;
            ; most of the time,
            ; select the best spot we've seen so far 
            ; and use that as the trip location
            ;
            ; however, occasionally choose an entirely
            ; new grid and add it to the preferred grids list
            ;
            let chance random-float 1.0
            ifelse ( chance >= 0.00 and chance <= 0.90 ) [
              ;
              ; pick the best performing spot
              ;
              set grid-id-val boats-select-best-location
            ]
            [
              ;; print (list "debug: boat " self " is adjusting preferred grids ")
              
              ;
              ; pick a new spot, dump an old spot
              ;
              let new-grid -1
              let new-grid-candidates []
              
              ;
              ; set up preferred grids (avoid MPAs if they are active)
              ;
              ifelse (MPAs-active? = false) [
                set new-grid-candidates ([tile-id] of tiles with [tile-cover-type = "ocean" ])
                foreach preferred-grids [
                  set new-grid-candidates (remove ? new-grid-candidates)
                ]
                set new-grid one-of new-grid-candidates
              ]
              [
                set new-grid-candidates ([tile-id] of tiles with [tile-cover-type = "ocean" ])
                foreach MPA-TILE-LIST [
                  set new-grid-candidates (remove ? new-grid-candidates)
                ]
                foreach preferred-grids [
                  set new-grid-candidates (remove ? new-grid-candidates)
                ]
                set new-grid one-of new-grid-candidates
              ]
              set grid-id-val new-grid
              
              ;
              ; now dump the lowest performing grid
              ;
              let worst-spot boats-select-worst-location
              set preferred-grids (remove worst-spot preferred-grids)
              
              ;; print (list "debug: boat " self "just chose new spot " new-grid ", dumped old spot " worst-spot)
            ] 
            
            
;            print (list "debug: best-spot computed as " grid-id-val)
;            print (list "trip-history = ")
;            foreach trip-history [
;              let trip-loc get-trip-destination ?
;              let trip-qty precision get-trip-dover-catch ? 0
;              type trip-loc type ":" type trip-qty type " ; "
;            ]
;            print " "

          ]
             
          ;
          ; setup trip parameters
          ;
          let start-time-val ticks + random 5                        ; start sometime in next 5 days
          let end-time-val start-time-val + 1 + random 4             ; trip is 1 to 4 days long
          let planned-effort-val 2 * (end-time-val - start-time-val) ; assume 2 tows of effort per day
          let dover-catch-val 0
          let rockfish-catch-val 0
                    
          ;
          ; create a new trip
          ;
          set current-trip (create-new-trip 
            grid-id-val 
            start-time-val end-time-val 
            planned-effort-val dover-catch-val rockfish-catch-val )
        ]
        
        ;
        ; now check to see if it's time to sail yet
        ;
        if ((get-trip-start-time current-trip) = ticks) [
          set trip-phase "outward-bound"
        ]
      ]
      
      ; ---------------------------------------------
      ;
      ; outward bound
      ;     
      ; ---------------------------------------------
      if (trip-phase = "outward-bound") [
        ;
        ; select a patch location in current trip preferred tile
        ;
        let spot one-of [tile-patch-set] of get-tile-id get-trip-destination current-trip
        move-to spot
        set trip-phase "on-station"
        set effort (get-trip-effort current-trip)     ; keep track of our projected trip cost
      ]
      
      
      ; ---------------------------------------------
      ;
      ; on station
      ;     
      ; ---------------------------------------------      
      if (trip-phase = "on-station") [
        ; 
        ; compute how much effort is remaining for this trip
        ;
        let remaining-effort ( get-trip-effort current-trip )
        
        ;
        ; if we still have planned effort, continue to fish
        ;
        ifelse (remaining-effort > 0) [
          boats-fish ( get-tile-id (get-trip-destination current-trip) )
          
          if (dover-catch < 0) [
            print (list "debug: warning: boat " self " reports negative dover catch " dover-catch)
          ]
          if (rockfish-catch < 0) [
            print (list "debug: warning: boat " self " reports negative rockfish catch " rockfish-catch)
          ]          
          
          let prev-dover-catch precision ( get-trip-dover-catch current-trip ) 2
          let prev-rockfish-catch precision ( get-trip-rockfish-catch current-trip ) 2
          
          set current-trip ( set-trip-dover-catch current-trip precision (dover-catch + prev-dover-catch) 2 )
          set current-trip ( set-trip-rockfish-catch current-trip precision (rockfish-catch + prev-rockfish-catch) 2 )
          
          set remaining-effort (remaining-effort - 1)
          set current-trip ( set-trip-effort current-trip remaining-effort )
          
          set dover-catch 0
          set rockfish-catch 0
        ]
        [
          ;
          ; all done, head for home
          ;
          set trip-phase "homeward-bound"
        ]
      ]
      
      ; ---------------------------------------------
      ;
      ; homeward bound
      ;
      ; ---------------------------------------------
      if (trip-phase = "homeward-bound") [
        let spot one-of harbor-spots
        move-to spot
        set trip-phase "in-port"
        
        ;
        ; compute economic results of this trip
        ;
        set wealth (wealth + (get-trip-dover-catch current-trip) + (get-trip-rockfish-catch current-trip))
        
        ; =============================================
        ; 
        ; check for presence of landing taxes
        ;
        ; =============================================
        let landing-tax-amount 0
        let cost-per-tow 50.0
        let operating-costs (cost-per-tow * effort)
        if (landing-taxes? = true) [
          set landing-tax-amount LANDING-TAX-RATE * (get-trip-dover-catch current-trip)
        ]
        set wealth precision (wealth - ( operating-costs + landing-tax-amount )) 2
        
        ;
        ; keep track of our trip history
        ; zero out current trip so we can plan for the next trip
        ;
        
        ; check to make sure current-trip data is OK
        if ((get-trip-dover-catch current-trip) < 0) [
          print (list "debug: warning: boat " self " has faulty current trip, dover-catch < 0 " current-trip)
        ]
        if ((get-trip-rockfish-catch current-trip) < 0) [
          print (list "debug: warning: boat " self " has faulty current trip, rockfish-catch < 0 " current-trip)
        ]  
              
        set trip-history ( fput current-trip trip-history )
        
        set catch-history (fput 
          (list 
            (get-trip-destination current-trip) 
            (get-trip-dover-catch current-trip) 
            (get-trip-rockfish-catch current-trip)) catch-history)
          
        ;;print (list "debug: before accumulation - catch history for boat " self " = " catch-history)
        set catch-history ( set-catch-history-mean catch-history )
        ;;print (list "debug: after accumulation - catch history for boat " self " = " catch-history)
        
        set current-trip []
      ]
    ]
  ]
end



; boats-fish
;
; model fishing operations at at particular tile
;
to boats-fish [ this-tile ]
  ;
  ; boats fish
  ;
  let dover-cpue  random-gamma ([dover-sole-day-cpue-mean] of this-tile) ([dover-sole-day-cpue-stdev] of this-tile)
  if (dover-cpue < 0) [
    print (list "debug: warning: dover-cpue random draw came up < 0 " dover-cpue)
  ]
  let dover-stock ([dover-sole-stock-size] of this-tile)
  let dover-catch-amt 0.001 * (dover-cpue * dover-stock)
  
  let rockfish-cpue  random-gamma ([darkblotched-rockfish-day-cpue-mean] of this-tile) ([darkblotched-rockfish-day-cpue-stdev] of this-tile)
  if (rockfish-cpue < 0) [
    print (list "debug: warning: rockfish-cpue random draw came up < 0 " rockfish-cpue)
  ]
  let rockfish-stock ([darkblotched-rockfish-stock-size] of this-tile)
  let rockfish-catch-amt 0.001 * (rockfish-cpue * rockfish-stock)
  
;  set dover-catch (dover-catch + dover-catch-amt)
;  set rockfish-catch (rockfish-catch + rockfish-catch-amt)
  set dover-catch dover-catch-amt
  set rockfish-catch rockfish-catch-amt
  
  ask this-tile [
    set dover-sole-stock-size (max (list 0 (dover-sole-stock-size - dover-catch-amt)))
    if (dover-sole-stock-size < 0) [ 
      print (list "debug: warning: dover stock < 0 for tile " 
        [tile-ID] of this-tile [tile-row] of this-tile [tile-col] of this-tile)
      set dover-sole-stock-size 0 
    ]
    
    set darkblotched-rockfish-stock-size (max (list 0 (darkblotched-rockfish-stock-size - rockfish-catch-amt)))
    if (darkblotched-rockfish-stock-size < 0) [ 
      print (list "debug: warning: rockfish stock < 0 for tile " 
        [tile-ID] of this-tile [tile-row] of this-tile [tile-col] of this-tile)
      set darkblotched-rockfish-stock-size 0 
    ]
  ]
end



to step
  ;
  ; update various timekeeping variables
  ;
  sim-timekeeping
  
  ;
  ; update biology and weather
  ;
  fish-grow
  ;; fish-move
  
  
  ;
  ; boats do fishing operations
  ;
  boats-operate
  
  ;
  ; update displays
  ;
  render-plots
  
  tick
end

to go
  step
end


; ==============================================================================
;
; support utilities
;
; ==============================================================================

; ---------------------------------------------
;
; list utilties
;
; ---------------------------------------------

; sequence [ start end delta ]
;
; utility to make a numeric list from start to end in steps of delta
;
to-report sequence[ lo hi interval ]
  let val []
  let flip? false
  
  ;
  ; check for inverted order  swap if needed
  ;
  if (hi < lo) [
    let tmp lo
    set lo hi
    set hi tmp
    set flip? true
  ]
  
  ;
  ; check for negative interval  invert if needed
  ;
  if (interval < 0) [ set interval (-1.0 * interval) ]
  
  ;
  ; build the sequence
  ;
  while [ lo <= hi ] [
    set val (lput lo val)
    set lo (lo + interval)
  ]
  
  ;
  ; report result (may need to be flipped)
  ;
  if (flip? = false) [ report val ]
  if (flip? = true) [ report reverse val ]
end

; ----------------------------------------------------
;
; date and time utilities
;
; ----------------------------------------------------

; day-num
;
; utility returns day number given a tick count
;
to-report day-num
  let value (1 + ((ticks mod 30)))
  report value
end

; month-num
;
; utility returns month number given a tick count
;
to-report month-num
  let value (((floor (ticks / 30)) mod 12) + 1)
  report value
end

; season-num
;
; utility reports season number given a tick count
;
to-report season-num
  let quarter 365 / 4
  let value ((floor (ticks / quarter)) mod 4) + 1
  report value
end

; season
;
; utility to report name of season
;
to-report season-name
  let value season-num
  if (value = 1) [ set value "winter" ]
  if (value = 2) [ set value "spring" ]
  if (value = 3) [ set value "summer" ]
  if (value = 4) [ set value "fall" ]  
  report value
end

; year-num
;
; utility returns year number given a tick count
;
to-report year-num
  let value (floor (ticks / 365)) + START-YEAR
  report value
end 

; julian-day-num
;
; utilty returns julian day given a tick count
;
to-report julian-day-num
  let value ((ticks mod 365) + 1)
  report value
end

; -----------------------------------------------
;
; math utilities
;
; -----------------------------------------------

; plus-or-minus [ n ]
;
; math function  returns +n or -n with
; equal probability
;
to-report plus-or-minus [ n ]
  let chance random 2
  if (chance = 0) [
    report n
  ]
  if (chance = 1) [
    report -1 * n
  ]
end



; -----------------------------------------------
;
; tile management utilities
;
; -----------------------------------------------

; get-tile-id
;
; returns the tile with the specified ID
;
to-report get-tile-id [ id-value ]
  let value one-of tiles with [tile-id = id-value]
  report value
end

; get-tile-row-col
;
; returns the tile with the specified row and col
;
to-report get-tile-row-col [ row-value col-value ]
  let value one-of tiles with [(tile-row = row-value) and (tile-col = col-value)]
  report value
end

; get-tile-patchset
;
; returns the patchset for a specified tile
;
to-report get-tile-patchset [ src-tile ]
  let value [tile-patch-set] of src-tile
  report value
end


; neighbors-tiles
;
; returns the Moore neighborhood of adjacent tiles to a tile
;
to-report moore-neighbors-tiles [ src-tile ]
  let row-val [tile-row] of src-tile
  let col-val [tile-col] of src-tile
  
  let rows sequence (row-val - 1) (row-val + 1) 1
  let cols sequence (col-val - 1) (col-val + 1) 1
  
  let tile-set []
  foreach rows [
    let row ?
    foreach cols [
      let col ?
      let tgt-tile one-of tiles with [ (tile-row = row) and (tile-col = col) ]
      if (tgt-tile != nobody) [
        set tile-set fput tgt-tile tile-set
      ]
    ]
  ]
  report turtle-set tile-set
end

; show-tiles
;
; debug function to report stock sizes of tiles
to show-tiles
  let tile-rows sequence 0 9 1
  let tile-cols sequence 0 9 1
  
  foreach tile-rows [
    let row-val ?
    let flag? false
    foreach tile-cols [
      let col-val ?
      
      ;; print (list "debug: show-tiles: row = " row-val "  col = " col-val)
      
      let a-tile one-of tiles with [ (tile-row = row-val) and (tile-col = col-val) ]
      let dover-val 0
      let rockfish-val 0
      ask a-tile [
        set dover-val precision dover-sole-stock-size 0
        set rockfish-val precision darkblotched-rockfish-stock-size 0
        if (dover-val < 0) or (rockfish-val < 0) [
          set flag? true
        ]
      ]
      
      ;;; type dover-val type "  " type rockfish-val type "; "
    ]
    ifelse (flag? = false)
    [ print " " ]
    [ print " - - - - - - - - - - - - - - - - - - - - " ]
  ]
  print " "
end

; -----------------------------------------------
;
; trip management utilities
;
; trip format:
; (grid-id start-tick end-tick planned-effort dover-catch rockfish-catch)
;
; -----------------------------------------------

;
; constructor
;
to-report create-new-trip [ grid-id start-time end-time planned-effort dover-catch-val rockfish-catch-val ]
  let value (list grid-id start-time end-time planned-effort dover-catch-val rockfish-catch-val)
  report value
end

;
; getters
;
to-report get-trip-destination [ trip ]
  let value item 0 trip
  report value
end

to-report get-trip-start-time [ trip ]
  let value item 1 trip
  report value
end

to-report get-trip-end-time [ trip ]
  let value item 2 trip
  report value
end

to-report get-trip-effort [ trip ]
  let value item 3 trip
  report value
end

to-report get-trip-dover-catch [ trip ]
  let value item 4 trip
  report value
end

to-report get-trip-rockfish-catch [ trip ]
  let value item 5 trip
  report value
end

;
; setters
;
to-report set-trip-destination [ trip grid-id ]
  let value (replace-item 0 trip grid-id)
  report value
end

to-report set-trip-start-time [ trip start-tick ]
  let value (replace-item 1 trip start-tick)
  report value
end

to-report set-trip-end-time [ trip end-tick]
  let value (replace-item 2 trip end-tick)
  report value
end

to-report set-trip-effort [ trip planned-effort ]
  let value (replace-item 3 trip planned-effort)
  report value
end

to-report set-trip-dover-catch [ trip dover-catch-val ]
  let value (replace-item 4 trip dover-catch-val)
  report value
end

to-report set-trip-rockfish-catch [ trip rockfish-catch-val]
  let value (replace-item 5 trip rockfish-catch-val)
  report value
end


; -----------------------------------------------
;
; catch-history management utilities
;
; catch-history format:
; (  ( grid-id cumulative-dover-catch cumulative-rockfish-catch ) ... )
;
; -----------------------------------------------

;
; getters
;
to-report get-catch-history-for-id [ id catch-history-list ]
  let value filter [ first ? = id ] catch-history-list
  report value
end

to-report get-catch-history-grid-id [ catch-history-item ]
  let value (item 0 catch-history-item)
  report value
end

to-report get-catch-history-dover-catch [ catch-history-item ]
  let cumulative-dover-catch (item 1 catch-history-item)
  report cumulative-dover-catch
end

to-report get-catch-history-rockfish-catch [ catch-history-item ]
  let cumulative-rockfish-catch  (item 2 catch-history-item)
  report cumulative-rockfish-catch 
end


; set-catch-history-sum
;
; method to iterate over catch history 
; and compute SUM of cumulative
; values of catch observed at each location
;
to-report set-catch-history-sum [ catch-history-list ]
  let new-list []
    
  ;
  ; get a list of locations
  ;
  let location-list sort remove-duplicates (map [ item 0 ? ] catch-history-list )
  
  foreach location-list [
    let location ?
    let items filter [ first ? = location ] catch-history-list
    ;; print (list "debug: for location = " location ", items = " items)
    
    ; accumulate dover total for this location
    let dover-location-sum sum map [ item 1 ? ] items
    set dover-location-sum precision dover-location-sum 2
    ;; print (list "debug: for dover-location-sum " dover-location-sum) 
 
    ; accumulate rockfish total for this location
    let rockfish-location-sum sum map [ item 2 ? ] items
    set rockfish-location-sum precision rockfish-location-sum 2  
    ;; print (list "debug: for rockfish-location-sum " dover-location-sum) 

    ;
    ; add a new entry to the end of the list
    ;   
    set new-list (lput (list location dover-location-sum rockfish-location-sum) new-list)
  ]
  
  ;
  ; create a new cumulative catch-history list
  ;
  report new-list
end


; set-catch-history-mean
;
; method to iterate over catch history 
; and compute MEAN of cumulative
; values of catch observed at each location
;
to-report set-catch-history-mean [ catch-history-list ]
  let new-list []
    
  ;
  ; get a list of locations
  ;
  let location-list sort remove-duplicates (map [ item 0 ? ] catch-history-list )
  
  foreach location-list [
    let location ?
    
    let items filter [ first ? = location ] catch-history-list
    ;; print (list "debug: for location = " location ", items = " items)
    
    ; compute dover mean for this location
    let dover-location-mean mean map [ item 1 ? ] items
    set dover-location-mean precision dover-location-mean 2    
    
    ; compute rockfish mean for this location
    let rockfish-location-mean mean map [ item 2 ? ] items
    set rockfish-location-mean precision rockfish-location-mean 2    
    
    ;
    ; add a new entry to the end of the list
    ;   
    set new-list (lput (list location dover-location-mean rockfish-location-mean) new-list)
  ]
  
  ;
  ; create a new cumulative catch-history list
  ;
  report new-list
end

;;;to test
;;;  let test-list (list (list 1 3) (list 2 4) (list 3 5) (list 3 7) (list 2 12))
;;;  print (list "debug: input list = " test-list)
;;;  
;;;  print (list "debug: first elements are : ")
;;;  print map [item 0 ?] test-list
;;;  
;;;  print (list "debug: second elements are : ")
;;;  print map [item 1 ?] test-list 
;;;  
;;;  print (list "debug: calling cumulator...")
;;;  let foo set-catch-history-cumulative test-list
;;;  print foo
;;;end
